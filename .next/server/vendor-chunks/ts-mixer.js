"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-mixer";
exports.ids = ["vendor-chunks/ts-mixer"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: () => (/* binding */ Mixin),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   hasMixin: () => (/* binding */ hasMixin),\n/* harmony export */   mix: () => (/* binding */ mix),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach((item) => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item) => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype)\n                .map((proto) => proto.constructor)\n                .filter((item) => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach((constituent) => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[0];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    var _a, _b, _c;\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n    decoratorsForType[key] = decoratorsForKey;\n    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkZBQTZGO0FBQzdGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixhQUFhOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlJQUF5SSxnR0FBZ0c7QUFDek8scUlBQXFJLDhGQUE4RjtBQUNuTyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSw4RkFBOEY7QUFDM08saUpBQWlKLGdHQUFnRztBQUNqUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0tBQXdLO0FBQ3hLLDBLQUEwSztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90cy1taXhlci9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCB3b3JrcyBsaWtlIGBPYmplY3QuYXBwbHlgLCBidXQgY29waWVzIGdldHRlcnMgYW5kIHNldHRlcnMgcHJvcGVybHkgYXMgd2VsbC4gIEFkZGl0aW9uYWxseSBnaXZlc1xuICogdGhlIG9wdGlvbiB0byBleGNsdWRlIHByb3BlcnRpZXMgYnkgbmFtZS5cbiAqL1xuY29uc3QgY29weVByb3BzID0gKGRlc3QsIHNyYywgZXhjbHVkZSA9IFtdKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzcmMpO1xuICAgIGZvciAobGV0IHByb3Agb2YgZXhjbHVkZSlcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlc3QsIHByb3BzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgY2hhaW4gb2YgcHJvdG90eXBlcyB1cCB1bnRpbCBPYmplY3QucHJvdG90eXBlIGdpdmVuIGEgc3RhcnRpbmcgb2JqZWN0LiAgVGhlIG9yZGVyIG9mIHByb3RvdHlwZXMgd2lsbFxuICogYmUgY2xvc2VzdCB0byBmYXJ0aGVzdCBpbiB0aGUgY2hhaW4uXG4gKi9cbmNvbnN0IHByb3RvQ2hhaW4gPSAob2JqLCBjdXJyZW50Q2hhaW4gPSBbb2JqXSkgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKHByb3RvID09PSBudWxsKVxuICAgICAgICByZXR1cm4gY3VycmVudENoYWluO1xuICAgIHJldHVybiBwcm90b0NoYWluKHByb3RvLCBbLi4uY3VycmVudENoYWluLCBwcm90b10pO1xufTtcbi8qKlxuICogSWRlbnRpZmllcyB0aGUgbmVhcmVzdCBhbmNlc3RvciBjb21tb24gdG8gYWxsIHRoZSBnaXZlbiBvYmplY3RzIGluIHRoZWlyIHByb3RvdHlwZSBjaGFpbnMuICBGb3IgbW9zdCB1bnJlbGF0ZWRcbiAqIG9iamVjdHMsIHRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBPYmplY3QucHJvdG90eXBlLlxuICovXG5jb25zdCBuZWFyZXN0Q29tbW9uUHJvdG8gPSAoLi4ub2JqcykgPT4ge1xuICAgIGlmIChvYmpzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgY29tbW9uUHJvdG8gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvdG9DaGFpbnMgPSBvYmpzLm1hcChvYmogPT4gcHJvdG9DaGFpbihvYmopKTtcbiAgICB3aGlsZSAocHJvdG9DaGFpbnMuZXZlcnkocHJvdG9DaGFpbiA9PiBwcm90b0NoYWluLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIGNvbnN0IHByb3RvcyA9IHByb3RvQ2hhaW5zLm1hcChwcm90b0NoYWluID0+IHByb3RvQ2hhaW4ucG9wKCkpO1xuICAgICAgICBjb25zdCBwb3RlbnRpYWxDb21tb25Qcm90byA9IHByb3Rvc1swXTtcbiAgICAgICAgaWYgKHByb3Rvcy5ldmVyeShwcm90byA9PiBwcm90byA9PT0gcG90ZW50aWFsQ29tbW9uUHJvdG8pKVxuICAgICAgICAgICAgY29tbW9uUHJvdG8gPSBwb3RlbnRpYWxDb21tb25Qcm90bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjb21tb25Qcm90bztcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcHJvdG90eXBlIG9iamVjdCB0aGF0IGlzIGEgbWl4dHVyZSBvZiB0aGUgZ2l2ZW4gcHJvdG90eXBlcy4gIFRoZSBtaXhpbmcgaXMgYWNoaWV2ZWQgYnkgZmlyc3RcbiAqIGlkZW50aWZ5aW5nIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBhbmQgdXNpbmcgaXQgYXMgdGhlIHByb3RvdHlwZSBmb3IgYSBuZXcgb2JqZWN0LiAgVGhlbiBhbGwgcHJvcGVydGllcy9tZXRob2RzXG4gKiBkb3duc3RyZWFtIG9mIHRoaXMgcHJvdG90eXBlIChPTkxZIGRvd25zdHJlYW0pIGFyZSBjb3BpZWQgaW50byB0aGUgbmV3IG9iamVjdC5cbiAqXG4gKiBUaGUgcmVzdWx0aW5nIHByb3RvdHlwZSBpcyBtb3JlIHBlcmZvcm1hbnQgdGhhbiBzb2Z0TWl4UHJvdG9zKC4uLiksIGFzIHdlbGwgYXMgRVM1IGNvbXBhdGlibGUuICBIb3dldmVyLCBpdCdzIG5vdCBhc1xuICogZmxleGlibGUgYXMgdXBkYXRlcyB0byB0aGUgc291cmNlIHByb3RvdHlwZXMgYXJlbid0IGNhcHR1cmVkIGJ5IHRoZSBtaXhlZCByZXN1bHQuICBTZWUgc29mdE1peFByb3RvcyBmb3Igd2h5IHlvdSBtYXlcbiAqIHdhbnQgdG8gdXNlIHRoYXQgaW5zdGVhZC5cbiAqL1xuY29uc3QgaGFyZE1peFByb3RvcyA9IChpbmdyZWRpZW50cywgY29uc3RydWN0b3IsIGV4Y2x1ZGUgPSBbXSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBiYXNlID0gKF9hID0gbmVhcmVzdENvbW1vblByb3RvKC4uLmluZ3JlZGllbnRzKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogT2JqZWN0LnByb3RvdHlwZTtcbiAgICBjb25zdCBtaXhlZFByb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICAvLyBLZWVwcyB0cmFjayBvZiBwcm90b3R5cGVzIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0byBhdm9pZCBjb3B5aW5nIHRoZSBzYW1lIHByb3BlcnRpZXMgbXVsdGlwbGUgdGltZXMuICBXZSBpbml0IHRoZVxuICAgIC8vIGxpc3Qgd2l0aCB0aGUgcHJvdG8gY2hhaW4gYmVsb3cgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnkgb2YgdGhvc2UgbWV0aG9kcyBtaXhlZCBpblxuICAgIC8vIHdoZW4gdGhleSB3aWxsIGFscmVhZHkgYmUgYWNjZXNzaWJsZSB2aWEgcHJvdG90eXBlIGFjY2Vzcy5cbiAgICBjb25zdCB2aXNpdGVkUHJvdG9zID0gcHJvdG9DaGFpbihiYXNlKTtcbiAgICBmb3IgKGxldCBwcm90b3R5cGUgb2YgaW5ncmVkaWVudHMpIHtcbiAgICAgICAgbGV0IHByb3RvcyA9IHByb3RvQ2hhaW4ocHJvdG90eXBlKTtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHByb3RvdHlwZSBjaGFpbiBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgb2xkIG1ldGhvZHMgZG9uJ3Qgb3ZlcnJpZGUgbmV3ZXIgb25lcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHByb3Rvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3RvID0gcHJvdG9zW2ldO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRQcm90b3MuaW5kZXhPZihuZXdQcm90bykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29weVByb3BzKG1peGVkUHJvdG8sIG5ld1Byb3RvLCBbJ2NvbnN0cnVjdG9yJywgLi4uZXhjbHVkZV0pO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRQcm90b3MucHVzaChuZXdQcm90byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWl4ZWRQcm90by5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBtaXhlZFByb3RvO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChhcnIpID0+IGFyci5maWx0ZXIoKGUsIGkpID0+IGFyci5pbmRleE9mKGUpID09IGkpO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmdyZWRpZW50IHdpdGggdGhlIGdpdmVuIHByb3AsIHNlYXJjaGluZyBpbiByZXZlcnNlIG9yZGVyIGFuZCBicmVhZHRoLWZpcnN0IGlmIHNlYXJjaGluZyBpbmdyZWRpZW50XG4gKiBwcm90b3R5cGVzIGlzIHJlcXVpcmVkLlxuICovXG5jb25zdCBnZXRJbmdyZWRpZW50V2l0aFByb3AgPSAocHJvcCwgaW5ncmVkaWVudHMpID0+IHtcbiAgICBjb25zdCBwcm90b0NoYWlucyA9IGluZ3JlZGllbnRzLm1hcChpbmdyZWRpZW50ID0+IHByb3RvQ2hhaW4oaW5ncmVkaWVudCkpO1xuICAgIC8vIHNpbmNlIHdlIHNlYXJjaCBicmVhZHRoLWZpcnN0LCB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygb3VyIGRlcHRoIGluIHRoZSBwcm90b3R5cGUgY2hhaW5zXG4gICAgbGV0IHByb3RvRGVwdGggPSAwO1xuICAgIC8vIG5vdCBhbGwgcHJvdG90eXBlIGNoYWlucyBhcmUgdGhlIHNhbWUgZGVwdGgsIHNvIHRoaXMgcmVtYWlucyB0cnVlIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbmdyZWRpZW50cydcbiAgICAvLyBwcm90b3R5cGUgY2hhaW5zIGhhcyBhbiBvYmplY3QgYXQgdGhpcyBkZXB0aFxuICAgIGxldCBwcm90b3NBcmVMZWZ0VG9TZWFyY2ggPSB0cnVlO1xuICAgIHdoaWxlIChwcm90b3NBcmVMZWZ0VG9TZWFyY2gpIHtcbiAgICAgICAgLy8gd2l0aCB0aGUgc3RhcnQgb2YgZWFjaCBob3Jpem9udGFsIHNsaWNlLCB3ZSBhc3N1bWUgdGhpcyBpcyB0aGUgb25lIHRoYXQncyBkZWVwZXIgdGhhbiBhbnkgb2YgdGhlIHByb3RvIGNoYWluc1xuICAgICAgICBwcm90b3NBcmVMZWZ0VG9TZWFyY2ggPSBmYWxzZTtcbiAgICAgICAgLy8gc2NhbiB0aHJvdWdoIHRoZSBpbmdyZWRpZW50cyByaWdodCB0byBsZWZ0XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmdyZWRpZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoVGFyZ2V0ID0gcHJvdG9DaGFpbnNbaV1bcHJvdG9EZXB0aF07XG4gICAgICAgICAgICBpZiAoc2VhcmNoVGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBzb21ldGhpbmcsIHRoaXMgaXMgcHJvb2YgdGhhdCB0aGlzIGhvcml6b250YWwgc2xpY2UgcG90ZW50aWFsbHkgbW9yZSBvYmplY3RzIHRvIHNlYXJjaFxuICAgICAgICAgICAgICAgIHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXVyZWthLCB3ZSBmb3VuZCBpdFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlYXJjaFRhcmdldCwgcHJvcCkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm90b0NoYWluc1tpXVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG9EZXB0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogXCJNaXhlc1wiIGluZ3JlZGllbnRzIGJ5IHdyYXBwaW5nIHRoZW0gaW4gYSBQcm94eS4gIFRoZSBvcHRpb25hbCBwcm90b3R5cGUgYXJndW1lbnQgYWxsb3dzIHRoZSBtaXhlZCBvYmplY3QgdG8gc2l0XG4gKiBkb3duc3RyZWFtIG9mIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBjaGFpbi4gIE5vdGUgdGhhdCBcInByb3BlcnRpZXNcIiBjYW5ub3QgYmUgYWRkZWQsIGRlbGV0ZWQsIG9yIG1vZGlmaWVkLlxuICovXG5jb25zdCBwcm94eU1peCA9IChpbmdyZWRpZW50cywgcHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZSkgPT4gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGU7XG4gICAgfSxcbiAgICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSB8fCB7fSwgcHJvcCk7XG4gICAgfSxcbiAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVmaW5lIG5ldyBwcm9wZXJ0aWVzIG9uIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgIH0sXG4gICAgaGFzKF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cykgIT09IHVuZGVmaW5lZCB8fCBwcm90b3R5cGVbcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiAoZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSB8fCBwcm90b3R5cGUpW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0KF8sIHByb3AsIHZhbCkge1xuICAgICAgICBjb25zdCBpbmdyZWRpZW50V2l0aFByb3AgPSBnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpO1xuICAgICAgICBpZiAoaW5ncmVkaWVudFdpdGhQcm9wID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbmV3IHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgICAgIGluZ3JlZGllbnRXaXRoUHJvcFtwcm9wXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVsZXRlIHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gaW5ncmVkaWVudHNcbiAgICAgICAgICAgIC5tYXAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpXG4gICAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBjdXJyLmNvbmNhdChwcmV2LmZpbHRlcihrZXkgPT4gY3Vyci5pbmRleE9mKGtleSkgPCAwKSkpO1xuICAgIH0sXG59KTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm94eS1wcm90b3R5cGUgb2JqZWN0IHRoYXQgaXMgYSBcInNvZnRcIiBtaXh0dXJlIG9mIHRoZSBnaXZlbiBwcm90b3R5cGVzLiAgVGhlIG1peGluZyBpcyBhY2hpZXZlZCBieVxuICogcHJveHlpbmcgYWxsIHByb3BlcnR5IGFjY2VzcyB0byB0aGUgaW5ncmVkaWVudHMuICBUaGlzIGlzIG5vdCBFUzUgY29tcGF0aWJsZSBhbmQgbGVzcyBwZXJmb3JtYW50LiAgSG93ZXZlciwgYW55XG4gKiBjaGFuZ2VzIG1hZGUgdG8gdGhlIHNvdXJjZSBwcm90b3R5cGVzIHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZSBwcm94eS1wcm90b3R5cGUsIHdoaWNoIG1heSBiZSBkZXNpcmFibGUuXG4gKi9cbmNvbnN0IHNvZnRNaXhQcm90b3MgPSAoaW5ncmVkaWVudHMsIGNvbnN0cnVjdG9yKSA9PiBwcm94eU1peChbLi4uaW5ncmVkaWVudHMsIHsgY29uc3RydWN0b3IgfV0pO1xuXG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgICBpbml0RnVuY3Rpb246IG51bGwsXG4gICAgc3RhdGljc1N0cmF0ZWd5OiAnY29weScsXG4gICAgcHJvdG90eXBlU3RyYXRlZ3k6ICdjb3B5JyxcbiAgICBkZWNvcmF0b3JJbmhlcml0YW5jZTogJ2RlZXAnLFxufTtcblxuLy8gS2VlcHMgdHJhY2sgb2YgY29uc3RpdHVlbnQgY2xhc3NlcyBmb3IgZXZlcnkgbWl4aW4gY2xhc3MgY3JlYXRlZCBieSB0cy1taXhlci5cbmNvbnN0IG1peGlucyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRNaXhpbnNGb3JDbGFzcyA9IChjbGF6eikgPT4gbWl4aW5zLmdldChjbGF6eik7XG5jb25zdCByZWdpc3Rlck1peGlucyA9IChtaXhlZENsYXNzLCBjb25zdGl0dWVudHMpID0+IG1peGlucy5zZXQobWl4ZWRDbGFzcywgY29uc3RpdHVlbnRzKTtcbmNvbnN0IGhhc01peGluID0gKGluc3RhbmNlLCBtaXhpbikgPT4ge1xuICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIG1peGluKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGZyb250aWVyID0gbmV3IFNldCgpO1xuICAgIGZyb250aWVyLmFkZChjb25zdHJ1Y3Rvcik7XG4gICAgd2hpbGUgKGZyb250aWVyLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcm9udGllciBoYXMgdGhlIG1peGluIHdlJ3JlIGxvb2tpbmcgZm9yLiAgaWYgbm90LCB3ZSBjYW4gc2F5IHdlIHZpc2l0ZWQgZXZlcnkgaXRlbSBpbiB0aGUgZnJvbnRpZXJcbiAgICAgICAgaWYgKGZyb250aWVyLmhhcyhtaXhpbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZnJvbnRpZXIuZm9yRWFjaCgoaXRlbSkgPT4gdmlzaXRlZC5hZGQoaXRlbSkpO1xuICAgICAgICAvLyBidWlsZCBhIG5ldyBmcm9udGllciBiYXNlZCBvbiB0aGUgYXNzb2NpYXRlZCBtaXhpbiBjbGFzc2VzIGFuZCBwcm90b3R5cGUgY2hhaW5zIG9mIGVhY2ggZnJvbnRpZXIgaXRlbVxuICAgICAgICBjb25zdCBuZXdGcm9udGllciA9IG5ldyBTZXQoKTtcbiAgICAgICAgZnJvbnRpZXIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgaXRlbUNvbnN0aXR1ZW50cyA9IChfYSA9IG1peGlucy5nZXQoaXRlbSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHByb3RvQ2hhaW4oaXRlbS5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgLm1hcCgocHJvdG8pID0+IHByb3RvLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db25zdGl0dWVudHMpXG4gICAgICAgICAgICAgICAgaXRlbUNvbnN0aXR1ZW50cy5mb3JFYWNoKChjb25zdGl0dWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGNvbnN0aXR1ZW50KSAmJiAhZnJvbnRpZXIuaGFzKGNvbnN0aXR1ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Zyb250aWVyLmFkZChjb25zdGl0dWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3ZSBoYXZlIGEgbmV3IGZyb250aWVyLCBub3cgc2VhcmNoIGFnYWluXG4gICAgICAgIGZyb250aWVyID0gbmV3RnJvbnRpZXI7XG4gICAgfVxuICAgIC8vIGlmIHdlIGdldCBoZXJlLCB3ZSBjb3VsZG4ndCBmaW5kIHRoZSBtaXhpbiBhbnl3aGVyZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9yIGFzc29jaWF0ZWQgbWl4aW4gY2xhc3Nlc1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycyA9IChvMSwgbzIpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGFsbEtleXMgPSB1bmlxdWUoWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8xKSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobzIpXSk7XG4gICAgY29uc3QgbWVyZ2VkT2JqZWN0ID0ge307XG4gICAgZm9yIChsZXQga2V5IG9mIGFsbEtleXMpXG4gICAgICAgIG1lcmdlZE9iamVjdFtrZXldID0gdW5pcXVlKFsuLi4oKF9hID0gbzEgPT09IG51bGwgfHwgbzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8xW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSwgLi4uKChfYiA9IG8yID09PSBudWxsIHx8IG8yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvMltrZXldKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSldKTtcbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0O1xufTtcbmNvbnN0IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzID0gKGQxLCBkMikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgcHJvcGVydHk6IG1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycygoX2EgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEucHJvcGVydHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCAoX2IgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIucHJvcGVydHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KSxcbiAgICAgICAgbWV0aG9kOiBtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMoKF9jID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLm1ldGhvZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIChfZCA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5tZXRob2QpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBtZXJnZURlY29yYXRvcnMgPSAoZDEsIGQyKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgcmV0dXJuICh7XG4gICAgICAgIGNsYXNzOiB1bmlxdWUoWy4uLihfYSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5jbGFzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIC4uLihfYiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5jbGFzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW11dKSxcbiAgICAgICAgc3RhdGljOiBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycygoX2MgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuc3RhdGljKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgKF9kID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLnN0YXRpYykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pLFxuICAgICAgICBpbnN0YW5jZTogbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMoKF9lID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLmluc3RhbmNlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB7fSwgKF9mID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLmluc3RhbmNlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB7fSksXG4gICAgfSk7XG59O1xuY29uc3QgZGVjb3JhdG9ycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGZpbmRBbGxDb25zdGl0dWVudENsYXNzZXMgPSAoLi4uY2xhc3NlcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGxDbGFzc2VzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGZyb250aWVyID0gbmV3IFNldChbLi4uY2xhc3Nlc10pO1xuICAgIHdoaWxlIChmcm9udGllci5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGxldCBjbGF6eiBvZiBmcm9udGllcikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9DaGFpbkNsYXNzZXMgPSBwcm90b0NoYWluKGNsYXp6LnByb3RvdHlwZSkubWFwKHByb3RvID0+IHByb3RvLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG1peGluQ2xhc3NlcyA9IChfYSA9IGdldE1peGluc0ZvckNsYXNzKGNsYXp6KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxseU5ld0NsYXNzZXMgPSBbLi4ucHJvdG9DaGFpbkNsYXNzZXMsIC4uLm1peGluQ2xhc3Nlc107XG4gICAgICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gcG90ZW50aWFsbHlOZXdDbGFzc2VzLmZpbHRlcihjID0+ICFhbGxDbGFzc2VzLmhhcyhjKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBuZXdDbGFzcyBvZiBuZXdDbGFzc2VzKVxuICAgICAgICAgICAgICAgIGZyb250aWVyLmFkZChuZXdDbGFzcyk7XG4gICAgICAgICAgICBhbGxDbGFzc2VzLmFkZChjbGF6eik7XG4gICAgICAgICAgICBmcm9udGllci5kZWxldGUoY2xhenopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWxsQ2xhc3Nlc107XG59O1xuY29uc3QgZGVlcERlY29yYXRvclNlYXJjaCA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW4gPSBmaW5kQWxsQ29uc3RpdHVlbnRDbGFzc2VzKC4uLmNsYXNzZXMpXG4gICAgICAgIC5tYXAoY2xhenogPT4gZGVjb3JhdG9ycy5nZXQoY2xhenopKVxuICAgICAgICAuZmlsdGVyKGRlY29yYXRvcnMgPT4gISFkZWNvcmF0b3JzKTtcbiAgICBpZiAoZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW4ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW4ubGVuZ3RoID09IDEpXG4gICAgICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpblswXTtcbiAgICByZXR1cm4gZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW4ucmVkdWNlKChkMSwgZDIpID0+IG1lcmdlRGVjb3JhdG9ycyhkMSwgZDIpKTtcbn07XG5jb25zdCBkaXJlY3REZWNvcmF0b3JTZWFyY2ggPSAoLi4uY2xhc3NlcykgPT4ge1xuICAgIGNvbnN0IGNsYXNzRGVjb3JhdG9ycyA9IGNsYXNzZXMubWFwKGNsYXp6ID0+IGdldERlY29yYXRvcnNGb3JDbGFzcyhjbGF6eikpO1xuICAgIGlmIChjbGFzc0RlY29yYXRvcnMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKGNsYXNzRGVjb3JhdG9ycy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBjbGFzc0RlY29yYXRvcnNbMF07XG4gICAgcmV0dXJuIGNsYXNzRGVjb3JhdG9ycy5yZWR1Y2UoKGQxLCBkMikgPT4gbWVyZ2VEZWNvcmF0b3JzKGQxLCBkMikpO1xufTtcbmNvbnN0IGdldERlY29yYXRvcnNGb3JDbGFzcyA9IChjbGF6eikgPT4ge1xuICAgIGxldCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBkZWNvcmF0b3JzLmdldChjbGF6eik7XG4gICAgaWYgKCFkZWNvcmF0b3JzRm9yQ2xhc3MpIHtcbiAgICAgICAgZGVjb3JhdG9yc0ZvckNsYXNzID0ge307XG4gICAgICAgIGRlY29yYXRvcnMuc2V0KGNsYXp6LCBkZWNvcmF0b3JzRm9yQ2xhc3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdG9yc0ZvckNsYXNzO1xufTtcbmNvbnN0IGRlY29yYXRlQ2xhc3MgPSAoZGVjb3JhdG9yKSA9PiAoKGNsYXp6KSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvckNsYXNzID0gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KTtcbiAgICBsZXQgY2xhc3NEZWNvcmF0b3JzID0gZGVjb3JhdG9yc0ZvckNsYXNzLmNsYXNzO1xuICAgIGlmICghY2xhc3NEZWNvcmF0b3JzKSB7XG4gICAgICAgIGNsYXNzRGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICBkZWNvcmF0b3JzRm9yQ2xhc3MuY2xhc3MgPSBjbGFzc0RlY29yYXRvcnM7XG4gICAgfVxuICAgIGNsYXNzRGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgcmV0dXJuIGRlY29yYXRvcihjbGF6eik7XG59KTtcbmNvbnN0IGRlY29yYXRlTWVtYmVyID0gKGRlY29yYXRvcikgPT4gKChvYmplY3QsIGtleSwgLi4ub3RoZXJBcmdzKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgZGVjb3JhdG9yVGFyZ2V0VHlwZSA9IHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicgPyAnc3RhdGljJyA6ICdpbnN0YW5jZSc7XG4gICAgY29uc3QgZGVjb3JhdG9yVHlwZSA9IHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJyA/ICdtZXRob2QnIDogJ3Byb3BlcnR5JztcbiAgICBjb25zdCBjbGF6eiA9IGRlY29yYXRvclRhcmdldFR5cGUgPT09ICdzdGF0aWMnID8gb2JqZWN0IDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGdldERlY29yYXRvcnNGb3JDbGFzcyhjbGF6eik7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPSAoX2EgPSBkZWNvcmF0b3JzRm9yQ2xhc3MgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvckNsYXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNvcmF0b3JzRm9yQ2xhc3NbZGVjb3JhdG9yVGFyZ2V0VHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGRlY29yYXRvcnNGb3JDbGFzc1tkZWNvcmF0b3JUYXJnZXRUeXBlXSA9IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlO1xuICAgIGxldCBkZWNvcmF0b3JzRm9yVHlwZSA9IChfYiA9IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlID09PSBudWxsIHx8IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZVtkZWNvcmF0b3JUeXBlXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgZGVjb3JhdG9yc0ZvclRhcmdldFR5cGVbZGVjb3JhdG9yVHlwZV0gPSBkZWNvcmF0b3JzRm9yVHlwZTtcbiAgICBsZXQgZGVjb3JhdG9yc0ZvcktleSA9IChfYyA9IGRlY29yYXRvcnNGb3JUeXBlID09PSBudWxsIHx8IGRlY29yYXRvcnNGb3JUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNvcmF0b3JzRm9yVHlwZVtrZXldKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICBkZWNvcmF0b3JzRm9yVHlwZVtrZXldID0gZGVjb3JhdG9yc0ZvcktleTtcbiAgICAvLyBAdHMtaWdub3JlOiBhcnJheSBpcyB0eXBlIGBBW10gfCBCW11gIGFuZCBpdGVtIGlzIHR5cGUgYEEgfCBCYCwgc28gdGVjaG5pY2FsbHkgYSB0eXBlIGVycm9yLCBidXQgaXQncyBmaW5lXG4gICAgZGVjb3JhdG9yc0ZvcktleS5wdXNoKGRlY29yYXRvcik7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBkZWNvcmF0b3Iob2JqZWN0LCBrZXksIC4uLm90aGVyQXJncyk7XG59KTtcbmNvbnN0IGRlY29yYXRlID0gKGRlY29yYXRvcikgPT4gKCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gZGVjb3JhdGVDbGFzcyhkZWNvcmF0b3IpKGFyZ3NbMF0pO1xuICAgIHJldHVybiBkZWNvcmF0ZU1lbWJlcihkZWNvcmF0b3IpKC4uLmFyZ3MpO1xufSk7XG5cbmZ1bmN0aW9uIE1peGluKC4uLmNvbnN0cnVjdG9ycykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHByb3RvdHlwZXMgPSBjb25zdHJ1Y3RvcnMubWFwKGNvbnN0cnVjdG9yID0+IGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgLy8gSGVyZSB3ZSBnYXRoZXIgdXAgdGhlIGluaXQgZnVuY3Rpb25zIG9mIHRoZSBpbmdyZWRpZW50IHByb3RvdHlwZXMsIGNvbWJpbmUgdGhlbSBpbnRvIG9uZSBpbml0IGZ1bmN0aW9uLCBhbmRcbiAgICAvLyBhdHRhY2ggaXQgdG8gdGhlIG1peGVkIGNsYXNzIHByb3RvdHlwZS4gIFRoZSByZWFzb24gd2UgZG8gdGhpcyBpcyBiZWNhdXNlIHdlIHdhbnQgdGhlIGluaXQgZnVuY3Rpb25zIHRvIG1peFxuICAgIC8vIHNpbWlsYXJseSB0byBjb25zdHJ1Y3RvcnMgLS0gbm90IG1ldGhvZHMsIHdoaWNoIHNpbXBseSBvdmVycmlkZSBlYWNoIG90aGVyLlxuICAgIGNvbnN0IGluaXRGdW5jdGlvbk5hbWUgPSBzZXR0aW5ncy5pbml0RnVuY3Rpb247XG4gICAgaWYgKGluaXRGdW5jdGlvbk5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW5pdEZ1bmN0aW9ucyA9IHByb3RvdHlwZXNcbiAgICAgICAgICAgIC5tYXAocHJvdG8gPT4gcHJvdG9baW5pdEZ1bmN0aW9uTmFtZV0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmMgPT4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpO1xuICAgICAgICBjb25zdCBjb21iaW5lZEluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbml0RnVuY3Rpb24gb2YgaW5pdEZ1bmN0aW9ucylcbiAgICAgICAgICAgICAgICBpbml0RnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4dHJhUHJvdG8gPSB7IFtpbml0RnVuY3Rpb25OYW1lXTogY29tYmluZWRJbml0RnVuY3Rpb24gfTtcbiAgICAgICAgcHJvdG90eXBlcy5wdXNoKGV4dHJhUHJvdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNaXhlZENsYXNzKC4uLmFyZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb25zdHJ1Y3RvciBvZiBjb25zdHJ1Y3RvcnMpXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBwb3RlbnRpYWxseSBhYnN0cmFjdCBjbGFzc1xuICAgICAgICAgICAgY29weVByb3BzKHRoaXMsIG5ldyBjb25zdHJ1Y3RvciguLi5hcmdzKSk7XG4gICAgICAgIGlmIChpbml0RnVuY3Rpb25OYW1lICE9PSBudWxsICYmIHR5cGVvZiB0aGlzW2luaXRGdW5jdGlvbk5hbWVdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhpc1tpbml0RnVuY3Rpb25OYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgTWl4ZWRDbGFzcy5wcm90b3R5cGUgPSBzZXR0aW5ncy5wcm90b3R5cGVTdHJhdGVneSA9PT0gJ2NvcHknXG4gICAgICAgID8gaGFyZE1peFByb3Rvcyhwcm90b3R5cGVzLCBNaXhlZENsYXNzKVxuICAgICAgICA6IHNvZnRNaXhQcm90b3MocHJvdG90eXBlcywgTWl4ZWRDbGFzcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE1peGVkQ2xhc3MsIHNldHRpbmdzLnN0YXRpY3NTdHJhdGVneSA9PT0gJ2NvcHknXG4gICAgICAgID8gaGFyZE1peFByb3Rvcyhjb25zdHJ1Y3RvcnMsIG51bGwsIFsncHJvdG90eXBlJ10pXG4gICAgICAgIDogcHJveHlNaXgoY29uc3RydWN0b3JzLCBGdW5jdGlvbi5wcm90b3R5cGUpKTtcbiAgICBsZXQgRGVjb3JhdGVkTWl4ZWRDbGFzcyA9IE1peGVkQ2xhc3M7XG4gICAgaWYgKHNldHRpbmdzLmRlY29yYXRvckluaGVyaXRhbmNlICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgY2xhc3NEZWNvcmF0b3JzID0gc2V0dGluZ3MuZGVjb3JhdG9ySW5oZXJpdGFuY2UgPT09ICdkZWVwJ1xuICAgICAgICAgICAgPyBkZWVwRGVjb3JhdG9yU2VhcmNoKC4uLmNvbnN0cnVjdG9ycylcbiAgICAgICAgICAgIDogZGlyZWN0RGVjb3JhdG9yU2VhcmNoKC4uLmNvbnN0cnVjdG9ycyk7XG4gICAgICAgIGZvciAobGV0IGRlY29yYXRvciBvZiAoX2EgPSBjbGFzc0RlY29yYXRvcnMgPT09IG51bGwgfHwgY2xhc3NEZWNvcmF0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc0RlY29yYXRvcnMuY2xhc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvcmF0b3IoRGVjb3JhdGVkTWl4ZWRDbGFzcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgRGVjb3JhdGVkTWl4ZWRDbGFzcyA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzKChfYiA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5zdGF0aWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LCBEZWNvcmF0ZWRNaXhlZENsYXNzKTtcbiAgICAgICAgYXBwbHlQcm9wQW5kTWV0aG9kRGVjb3JhdG9ycygoX2MgPSBjbGFzc0RlY29yYXRvcnMgPT09IG51bGwgfHwgY2xhc3NEZWNvcmF0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc0RlY29yYXRvcnMuaW5zdGFuY2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCBEZWNvcmF0ZWRNaXhlZENsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTWl4aW5zKERlY29yYXRlZE1peGVkQ2xhc3MsIGNvbnN0cnVjdG9ycyk7XG4gICAgcmV0dXJuIERlY29yYXRlZE1peGVkQ2xhc3M7XG59XG5jb25zdCBhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzID0gKHByb3BBbmRNZXRob2REZWNvcmF0b3JzLCB0YXJnZXQpID0+IHtcbiAgICBjb25zdCBwcm9wRGVjb3JhdG9ycyA9IHByb3BBbmRNZXRob2REZWNvcmF0b3JzLnByb3BlcnR5O1xuICAgIGNvbnN0IG1ldGhvZERlY29yYXRvcnMgPSBwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycy5tZXRob2Q7XG4gICAgaWYgKHByb3BEZWNvcmF0b3JzKVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcHJvcERlY29yYXRvcnMpXG4gICAgICAgICAgICBmb3IgKGxldCBkZWNvcmF0b3Igb2YgcHJvcERlY29yYXRvcnNba2V5XSlcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChtZXRob2REZWNvcmF0b3JzKVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbWV0aG9kRGVjb3JhdG9ycylcbiAgICAgICAgICAgIGZvciAobGV0IGRlY29yYXRvciBvZiBtZXRob2REZWNvcmF0b3JzW2tleV0pXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSk7XG59O1xuLyoqXG4gKiBBIGRlY29yYXRvciB2ZXJzaW9uIG9mIHRoZSBgTWl4aW5gIGZ1bmN0aW9uLiAgWW91J2xsIHdhbnQgdG8gdXNlIHRoaXMgaW5zdGVhZCBvZiBgTWl4aW5gIGZvciBtaXhpbmcgZ2VuZXJpYyBjbGFzc2VzLlxuICovXG5jb25zdCBtaXggPSAoLi4uaW5ncmVkaWVudHMpID0+IGRlY29yYXRlZENsYXNzID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbWl4ZWRDbGFzcyA9IE1peGluKC4uLmluZ3JlZGllbnRzLmNvbmNhdChbZGVjb3JhdGVkQ2xhc3NdKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1peGVkQ2xhc3MsICduYW1lJywge1xuICAgICAgICB2YWx1ZTogZGVjb3JhdGVkQ2xhc3MubmFtZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiBtaXhlZENsYXNzO1xufTtcblxuZXhwb3J0IHsgTWl4aW4sIGRlY29yYXRlLCBoYXNNaXhpbiwgbWl4LCBzZXR0aW5ncyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-mixer/dist/esm/index.js\n");

/***/ })

};
;